#!/bin/bash
# Template Version: 16 | ContextKit: 0.2.0 | Updated: 2025-12-26

# Custom Claude Code statusline:
# Format: Chat: ████░░░░░░ 44% (87k/200k) | 5h-Usage: 61% (2.3h left)
# With colored progress bar for chat context
#
# Usage: CustomStatusline.sh --plan Pro|Max5|Max20
# Plan parameter is required for accurate cost tracking

# ⚠️ FOR DEVELOPERS: Do not edit this file - changes will be overwritten during ContextKit updates.
# Report bugs: https://github.com/FlineDev/ContextKit/issues

# Read stdin JSON from Claude Code
input=$(cat)

# Color definitions
YELLOW='\033[33m'       # Normal yellow
RED='\033[31m'          # Bright red
LIGHT_GRAY='\033[37m'   # Light gray text
RESET='\033[0m'

# Cache file locations
WINDOW_CACHE="$HOME/.claude/statusline-window.json"
COST_CACHE="$HOME/.claude/statusline-costs.json"

# Helper function: Floor timestamp to nearest hour (UTC)
# Input: ISO 8601 timestamp (e.g., "2025-12-16T09:45:30Z")
# Output: ISO 8601 timestamp floored to hour (e.g., "2025-12-16T09:00:00Z")
floor_to_hour() {
    local timestamp="$1"
    # Extract date and hour, set minutes/seconds to 00
    echo "${timestamp:0:14}00:00Z"
}

# Helper function: Detect current 5h window by traversing ALL activity chronologically
# Handles consecutive windows (e.g., 12h of continuous work = 3 windows)
# Algorithm:
#   1. Collect all user message timestamps from recent transcripts
#   2. Sort chronologically and traverse
#   3. Track window boundaries: when activity >= window_end, new window starts
#   4. Return the window that contains "now"
# Returns: ISO 8601 timestamp of current window start (floored to hour)
detect_window_start_global() {
    local now_ts=$(date -u +%s)
    local temp_file=$(mktemp)

    # Collect ALL user message timestamps from transcripts (last 24h to catch long sessions)
    for transcript in $(find "$HOME/.claude/projects" -name "*.jsonl" -type f -mmin -1440 2>/dev/null); do
        # Get first user message timestamp from each transcript
        local first_msg=$(jq -r 'select(.type == "user") | .timestamp' "$transcript" 2>/dev/null | head -1)

        if [[ -n "$first_msg" && "$first_msg" != "null" ]]; then
            # Truncate milliseconds and convert to unix timestamp
            local clean_ts="${first_msg%.*}Z"
            local msg_ts=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$clean_ts" +%s 2>/dev/null)

            if [[ -n "$msg_ts" ]]; then
                echo "$msg_ts $first_msg" >> "$temp_file"
            fi
        fi
    done

    # Sort timestamps chronologically
    sort -n "$temp_file" -o "$temp_file"

    # Traverse to find current window
    local current_window_start=""
    local current_window_end=0

    while read -r ts_unix ts_iso; do
        if [[ -z "$current_window_start" ]]; then
            # First activity - start first window
            current_window_start=$(floor_to_hour "$ts_iso")
            local start_ts=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$current_window_start" +%s 2>/dev/null)
            current_window_end=$((start_ts + 18000))  # +5 hours
        elif [[ $ts_unix -ge $current_window_end ]]; then
            # Activity after window ended - start new window
            current_window_start=$(floor_to_hour "$ts_iso")
            local start_ts=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$current_window_start" +%s 2>/dev/null)
            current_window_end=$((start_ts + 18000))  # +5 hours
        fi
        # else: activity within current window, no change
    done < "$temp_file"

    rm -f "$temp_file"

    # Verify we're still within the detected window
    if [[ -n "$current_window_start" && $now_ts -lt $current_window_end ]]; then
        echo "$current_window_start"
    else
        # Window expired and no new activity yet - return empty
        return 1
    fi
}

# Helper function: Read and validate window cache
# Returns: 0 if valid cache exists, 1 otherwise
# Sets: WINDOW_START, WINDOW_END, TIME_REMAINING (in seconds)
read_window_cache() {
    if [[ ! -f "$WINDOW_CACHE" ]]; then
        return 1
    fi

    local window_end=$(jq -r '.windowEnd' "$WINDOW_CACHE" 2>/dev/null)
    if [[ -z "$window_end" || "$window_end" == "null" ]]; then
        return 1
    fi

    # Check if window is still valid
    local now_ts=$(date -u +%s)
    local end_ts=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$window_end" +%s 2>/dev/null)

    if [[ -z "$end_ts" ]] || [[ $now_ts -ge $end_ts ]]; then
        # Window expired
        return 1
    fi

    # Valid cache - export values
    WINDOW_START=$(jq -r '.windowStart' "$WINDOW_CACHE")
    WINDOW_END="$window_end"
    TIME_REMAINING=$((end_ts - now_ts))
    return 0
}

# Helper function: Write window cache (atomic)
# Args: $1=windowStart, $2=windowEnd
write_window_cache() {
    local window_start="$1"
    local window_end="$2"

    # Atomic write using temp file
    echo "{\"windowStart\":\"$window_start\",\"windowEnd\":\"$window_end\"}" > "$WINDOW_CACHE.tmp"
    mv "$WINDOW_CACHE.tmp" "$WINDOW_CACHE"
}

# Helper function: Initialize cost cache if missing
initialize_cost_cache() {
    if [[ ! -f "$COST_CACHE" ]]; then
        echo '{"windowStart":"","sessions":{}}' > "$COST_CACHE"
    fi
}

# Helper function: Transition to new 5h window
# Each session's baseline becomes its previous latest value (last cost from old window)
# This way, usage in new window = latest - baseline = only NEW spending
# Removes sessions not updated in 30 days to keep file small
# Args: $1=new windowStart timestamp
transition_to_new_window() {
    local new_window_start="$1"
    local thirty_days_ago_ts=$(($(date -u +%s) - 2592000))  # 30 days in seconds

    jq --arg ws "$new_window_start" --argjson cutoff "$thirty_days_ago_ts" '
        .windowStart = $ws |
        # Set baseline = latest for each session (new window, usage resets to 0)
        .sessions |= with_entries(
            .value.baseline = .value.latest
        ) |
        # Remove sessions not updated in 30 days
        .sessions |= with_entries(
            select(
                (.value.updatedAt | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) > $cutoff
            )
        )
    ' "$COST_CACHE" > "$COST_CACHE.tmp" && mv "$COST_CACHE.tmp" "$COST_CACHE"
}

# Helper function: Update session cost in cache
# - Existing sessions: baseline stays (carried from previous window), latest updates
# - New sessions: baseline=0 (new chat, counts from start), latest=current cost
# - Reset detection: if cost < baseline, the session's cost counter was reset
#   This happens when: resuming old sessions, /compact, or auto-compact at 95% context
#   See: https://github.com/anthropics/claude-code/issues/13088
#   When detected, we reset baseline=0 to count new spending from the reset point
# Args: $1=session_id, $2=current_cost
update_session_cost() {
    local session_id="$1"
    local cost="$2"
    local timestamp=$(date -u "+%Y-%m-%dT%H:%M:%SZ")

    # Skip if missing data
    if [[ -z "$session_id" || -z "$cost" || "$cost" == "null" ]]; then
        return 0
    fi

    jq --arg sid "$session_id" --argjson cost "$cost" --arg ts "$timestamp" '
        if .sessions[$sid] then
            # Check if session was reset (cost decreased) - reset baseline to 0
            if $cost < .sessions[$sid].baseline then
                .sessions[$sid].baseline = 0 |
                .sessions[$sid].latest = $cost |
                .sessions[$sid].updatedAt = $ts
            else
                .sessions[$sid].latest = $cost |
                .sessions[$sid].updatedAt = $ts
            end
        else
            .sessions[$sid] = {
                "baseline": 0,
                "latest": $cost,
                "updatedAt": $ts
            }
        end
    ' "$COST_CACHE" > "$COST_CACHE.tmp" && mv "$COST_CACHE.tmp" "$COST_CACHE"
}

# Helper function: Calculate total usage within current 5h window
# For each session: usage = latest - baseline (spending in this window only)
# Uses max(0, ...) as safety net for any cached sessions with stale baseline > latest
# (update_session_cost now resets baseline when this is detected, but old cache entries may exist)
# Returns sum of all session usages
calculate_window_usage() {
    jq '[.sessions | to_entries[] | [(.value.latest - .value.baseline), 0] | max] | add // 0' "$COST_CACHE"
}

# Parse command line arguments
PLAN=""  # No default - must be specified

while [[ $# -gt 0 ]]; do
    case $1 in
        --plan)
            PLAN="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 --plan Pro|Max5|Max20"
            echo "Plan is required for accurate cost tracking"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 --plan Pro|Max5|Max20"
            exit 1
            ;;
    esac
done

# Validate that plan was provided
if [[ -z "$PLAN" ]]; then
    echo "Error: --plan parameter is required"
    echo "Usage: $0 --plan Pro|Max5|Max20"
    exit 1
fi

# Set block budget based on plan
case "$PLAN" in
    "Pro")
        BLOCK_BUDGET="16.00"
        ;;
    "Max5")
        BLOCK_BUDGET="80.00"
        ;;
    "Max20")
        BLOCK_BUDGET="320.00"
        ;;
    *)
        echo "Invalid plan: $PLAN. Use Pro, Max5, or Max20"
        exit 1
        ;;
esac

# Allow environment variable override
BLOCK_BUDGET=${CLAUDE_BLOCK_BUDGET:-$BLOCK_BUDGET}

# Function to create colored progress bar and return color
create_progress_bar() {
    local percent=$1
    local width=10
    local filled=$((percent * width / 100))
    local empty=$((width - filled))

    # Choose color based on percentage
    local color
    if [[ $percent -lt 50 ]]; then
        color="$LIGHT_GRAY"
    elif [[ $percent -lt 80 ]]; then
        color="$YELLOW"
    else
        color="$RED"
    fi

    local bar=""

    # Add filled and empty portions
    for ((i=0; i<filled; i++)); do
        bar+="▓"
    done
    for ((i=0; i<empty; i++)); do
        bar+="░"
    done

    # Return both bar and color (separated by |)
    echo "${color}${bar}|${color}"
}

# Extract context window data from stdin JSON
CONTEXT_SIZE=$(echo "$input" | jq -r '.context_window.context_window_size // 200000')
CURRENT_USAGE=$(echo "$input" | jq '.context_window.current_usage')

# Calculate current context usage from current_usage fields
if [[ "$CURRENT_USAGE" != "null" && -n "$CURRENT_USAGE" ]]; then
    # Current tokens = input + cache_creation + cache_read
    # (output tokens are not included in context window calculation)
    CURRENT_TOKENS=$(echo "$CURRENT_USAGE" | jq '.input_tokens + .cache_creation_input_tokens + .cache_read_input_tokens')
    context_percent=$((CURRENT_TOKENS * 100 / CONTEXT_SIZE))

    # Convert to k format for display
    tokens_k=$(((CURRENT_TOKENS + 999) / 1000))
    context_size_k=$((CONTEXT_SIZE / 1000))
else
    # Fallback if current_usage not available yet
    context_percent=0
    tokens_k=0
    context_size_k=200
fi

# Detect 5h billing window
# Fast path: Use cached window if valid (not expired)
# Slow path: Only scan ALL transcripts on first usage or when window expires
if read_window_cache; then
    # Cache hit and window still valid - use it directly (fast path)
    total_minutes_left=$((TIME_REMAINING / 60))
else
    # Cache miss or expired - run expensive global detection (slow path, first usage only)
    WINDOW_START=$(detect_window_start_global)

    if [[ -n "$WINDOW_START" ]]; then
        # Calculate window end: start + 5 hours
        start_ts=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$WINDOW_START" +%s 2>/dev/null)
        end_ts=$((start_ts + 18000))  # +5 hours (18000 seconds)
        WINDOW_END=$(date -u -j -f "%s" "$end_ts" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null)

        # Write to cache (atomic)
        write_window_cache "$WINDOW_START" "$WINDOW_END"

        # Calculate time remaining
        now_ts=$(date -u +%s)
        TIME_REMAINING=$((end_ts - now_ts))
        total_minutes_left=$((TIME_REMAINING / 60))
    fi
fi

# Cost tracking: Track usage WITHIN current 5h window using baseline/latest approach
#
# How it works:
#   - For each session, we store: baseline (cost at window start) and latest (current cost)
#   - Session's usage in this window = latest - baseline
#   - Total 5h usage = sum of all session usages
#
# Known limitation we work around:
#   Claude Code's cost.total_cost_usd resets when sessions are resumed or compacted
#   (see https://github.com/anthropics/claude-code/issues/13088)
#   When we detect cost < baseline, we reset baseline=0 to avoid negative usage values
if [[ -n "$WINDOW_START" ]]; then
    initialize_cost_cache

    # Check if we transitioned to a new window
    CACHED_WINDOW_START=$(jq -r '.windowStart // ""' "$COST_CACHE" 2>/dev/null)
    if [[ "$CACHED_WINDOW_START" != "$WINDOW_START" ]]; then
        # New window! Set baseline = latest for all sessions (usage resets to 0)
        transition_to_new_window "$WINDOW_START"
    fi

    # Update current session's cost (baseline stays, latest updates)
    SESSION_ID=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)
    CURRENT_COST=$(echo "$input" | jq -r '.cost.total_cost_usd // 0' 2>/dev/null)

    if [[ -n "$SESSION_ID" && "$CURRENT_COST" != "0" ]]; then
        update_session_cost "$SESSION_ID" "$CURRENT_COST"
    fi

    # Calculate total usage in this window: sum of (latest - baseline)
    WINDOW_USAGE=$(calculate_window_usage)

    # Calculate usage percentage
    if [[ -n "$WINDOW_USAGE" && -n "$BLOCK_BUDGET" ]] && [[ $(echo "$WINDOW_USAGE > 0" | bc) -eq 1 ]]; then
        window_percent=$(echo "scale=0; ($WINDOW_USAGE * 100) / $BLOCK_BUDGET" | bc)
        if [[ $window_percent -gt 100 ]]; then
            window_percent=100
        fi
    else
        window_percent=0
    fi
fi

# Format 5h-Usage display
if [[ -n "$WINDOW_START" && -n "$TIME_REMAINING" && $TIME_REMAINING -gt 0 ]]; then
    # Format time display: minutes if < 60, decimal hours if >= 60
    if [[ $total_minutes_left -lt 60 ]]; then
        time_display="${total_minutes_left}m left"
    else
        # Convert to decimal hours with 1 decimal place
        hours_decimal=$(echo "scale=1; $total_minutes_left / 60" | bc)
        time_display="${hours_decimal}h left"
    fi
    window_info="5h-Usage: ${window_percent}% (${time_display})"
else
    # No window detected - show fallback
    window_info="5h-Usage: N/A (awaiting usage)"
fi

# Format chat context with progress bar using built-in current_usage data
if [[ "$CURRENT_USAGE" != "null" && -n "$CURRENT_USAGE" ]]; then
    # Create colored progress bar
    progress_result=$(create_progress_bar $context_percent)
    progress_bar=$(echo "$progress_result" | cut -d'|' -f1)
    text_color=$(echo "$progress_result" | cut -d'|' -f2)

    context_info="Chat: ${progress_bar} ${text_color}${context_percent}% (${tokens_k}k/${context_size_k}k)${LIGHT_GRAY}"
else
    context_info="Chat: N/A (awaiting usage)"
fi

# Output statusline
echo -e "${LIGHT_GRAY}$context_info | $window_info${RESET}"